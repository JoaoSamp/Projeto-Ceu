data IActor.IVulture with
	var& IActor target;
end

code/call Create_Vulture (var IVector start_pos, var& IMap imap, var& IActor target) -> IActor.IVulture
do
    var IVector size            = val IVector(16, 16);
    var IMoving_Obj imov_obj     = call Create_Moving_Obj( start_pos, size);

    var IActor.IVulture ivult = val IActor.IVulture ( imov_obj, &imap, 35, 35, 0, 0, _, _, _, _, &target );
    escape ivult;
end

code/await Vulture_Cannon_Ball (var IVector position, var IVector cball_speed, var& IMap imap) -> none
do
	var IActor.ICannon_Ball ic_ball = call Create_Cannon_Ball (position, cball_speed, &imap );
	var&? Actor c_ball = spawn Actor(&ic_ball) in imap.all_actors;
	await c_ball;
end

code/await Vulture ( var& IActor.IVulture ivult ) -> none
do    
    var IVector sprite_size      = val IVector(48, 48);
    var IVector sprite_offset    = val IVector(24, 24);
    var& SDL_Open_Image img_idle = spawn SDL_Open_Image(&outer.renderer, "assets/img/actors/medSqr.png");

    var IImage_Quad iq_idle    = val IImage_Quad( &img_idle,     sprite_size, _ );
    var IAnimation ianim_idle  = val IAnimation( iq_idle,       sprite_offset, 1 );

    pool[] Vulture_Cannon_Ball c_balls;
    var real x_speed = 60;
    var real y_speed = 40;
    var real max_speed = 400;
    par/or do
        var int dt;
        every dt in SDL_DT do
            if ivult.imov_obj.speed.y == 0 then
            	y_speed = y_speed * -1;
            	ivult.imov_obj.speed.y = y_speed;
            end
        end
    with
    	loop do
            await Animation (&ianim_idle, &ivult.imov_obj.aabb.center, &ivult.imov_obj.aabb.scale, &ivult.imov_obj.aabb.rotate_angle );
    	end
    with
    	par/or do
    		ivult.imov_obj.speed = val IVector (-x_speed, y_speed);
            var IVector final_speed = val IVector(0,0);
    		await 500ms;
    		ivult.imov_obj.speed = val IVector (0, y_speed);
    		par/or do
    			every 750ms do
	    			var IVector cannon_ball_speed = val IVector(120, 0);
	    			if ivult.target.imov_obj.aabb.center.x < ivult.imov_obj.aabb.center.x then
	    				cannon_ball_speed.x = cannon_ball_speed.x * -1;
	    			end
	    			spawn Vulture_Cannon_Ball (ivult.imov_obj.aabb.center, cannon_ball_speed, &ivult.imap ) in c_balls;
	    		end
			with
				await 20s;
			end
            call Bound_Actor(&ivult, false);
            var IVector speed_vector = call Vec_Sub(ivult.target.imov_obj.aabb.center, ivult.imov_obj.aabb.center);
            var real angle = _atan2(speed_vector.x, speed_vector.y);
            var real x_speed = max_speed * _sin(angle);
            var real y_speed = max_speed * _cos(angle);
            ivult.imov_obj.speed = val IVector (x_speed, y_speed);
			every SDL_DT do
				if call Off_Screen(&ivult) then
					break;
				end
			end
    	with
    		await ivult.hit;
    	end
    end
end

code/await/dynamic Actor ( var&/dynamic IActor.IVulture iact )
    -> ( var IActor.IVulture iactor = iact )
         -> none
do
    await Vulture (&iactor);
end