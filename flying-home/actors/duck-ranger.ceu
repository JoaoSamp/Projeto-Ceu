data IActor.IDuck_Ranger with
	var& IActor target;
end

code/call Create_Duck_Ranger (var IVector start_pos, var& IMap imap, var& IActor target) -> IActor.IDuck_Ranger
do
    var IVector size            = val IVector(16, 16);
    var IMoving_Obj imov_obj     = call Create_Moving_Obj( start_pos, size);

    var IActor.IDuck_Ranger iranger = val IActor.IDuck_Ranger ( imov_obj, &imap, 35, 35, 0, 0, _, _, _, _, &target );
    escape iranger;
end

code/await Duck_Ranger ( var& IActor.IDuck_Ranger iranger ) -> none
do    
    var IVector sprite_size      = val IVector(48, 48);
    var IVector sprite_offset    = val IVector(24, 24);
    var& SDL_Open_Image img_idle = spawn SDL_Open_Image(&outer.renderer, "assets/img/actors/smallSqr.png");

    var IImage_Quad iq_idle    = val IImage_Quad( &img_idle,     sprite_size, _ );
    var IAnimation ianim_idle  = val IAnimation( iq_idle,       sprite_offset, 1 );

    par/or do
        var int dt;
        every dt in SDL_DT do
        end
    with
    	loop do
            await Animation (&ianim_idle, &iranger.imov_obj.aabb.center, &iranger.imov_obj.aabb.scale, &iranger.imov_obj.aabb.rotate_angle );
    	end
    with
    	par/or do
            var real max_speed = 300;
            var real x_speed = 60;
            var real y_speed = 40;
            iranger.imov_obj.speed          = val IVector (-x_speed, y_speed);
            var IVector final_speed = val IVector(0,0);
            await 1s;
            var int i;
            loop i in [1->2] do
                var IVector start_pos       = iranger.imov_obj.aabb.center;
                var IVector final_pos       = iranger.target.imov_obj.aabb.center;
                var IVector speed_vector    = call Vec_Sub(final_pos, start_pos);
                var real angle = _atan2(speed_vector.x, speed_vector.y);
                x_speed = max_speed * _sin(angle);
                y_speed = max_speed * _cos(angle);
                iranger.imov_obj.speed = val IVector (x_speed, y_speed);
                var real dist = 0;
                every SDL_DT do
                    var IVector dist_vec = call Vec_Sub(final_pos, iranger.imov_obj.aabb.center);
                    dist = _sqrt((dist_vec.x * dist_vec.x) + (dist_vec.y * dist_vec.y));
                    if dist < 20 then
                        break;
                    end
                end
                every SDL_DT do
                    var IVector dist_vec = call Vec_Sub(final_pos, iranger.imov_obj.aabb.center);
                    dist = _sqrt((dist_vec.x * dist_vec.x) + (dist_vec.y * dist_vec.y));
                    if dist > 20 then
                        break;
                    end
                end
                iranger.imov_obj.speed = val IVector(0, 0);
                await 1s;
            end
            var IVector start_pos       = iranger.imov_obj.aabb.center;
            var IVector final_pos       = iranger.target.imov_obj.aabb.center;
            var IVector speed_vector    = call Vec_Sub(final_pos, start_pos);
            var real angle = _atan2(speed_vector.x, speed_vector.y);
            x_speed = max_speed * _sin(angle);
            y_speed = max_speed * _cos(angle);
            call Bound_Actor(&iranger, false);
            iranger.imov_obj.speed = val IVector (x_speed, y_speed);
            every SDL_DT do
                if call Off_Screen(&iranger) then
                    break;
                end
            end
    	with
    		await iranger.hit;
    	end
    end
end

code/await/dynamic Actor ( var&/dynamic IActor.IDuck_Ranger iact )
    -> ( var IActor.IDuck_Ranger iactor = iact )
         -> none
do
    await Duck_Ranger (&iactor);
end

code/await/dynamic Hit_Actor (var&/dynamic IActor.IDuck_Ranger hitman, var&/dynamic IActor.IPlayer hitted) -> none
do
    var real value = -(_rand()%5 + 8);
    call Change_Life (value, &hitted);
    emit hitted.hit;
    emit hitted.stun(150);
end