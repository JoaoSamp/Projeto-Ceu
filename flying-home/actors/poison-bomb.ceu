data IActor.IPoison_Bomb;

code/call Create_Poison_Bomb (var IVector start_pos, var IVector speed, var& IMap imap) -> IActor.IPoison_Bomb
do
    var IVector size             = val IVector(14, 14);
    var IMoving_Obj imov_obj     = call Create_Moving_Obj( start_pos, size);
    imov_obj.speed = speed;
	var IActor.IPoison_Bomb ip_bomb = val IActor.IPoison_Bomb( imov_obj, &imap, 0, 0, 0, 0, _, _, _, _ );
    call Bound_Actor (&ip_bomb, false);
    ip_bomb.imov_obj.bound_top = true;
    escape ip_bomb;
end

code/await Poison_Bomb (var& IActor.IPoison_Bomb ip_bomb) -> none
do  
    var IVector sprite_size      = val IVector(32, 32);
    var IVector sprite_offset    = val IVector(16, 16);

    var& SDL_Open_Image img_idle       = spawn SDL_Open_Image(&outer.renderer, "assets/img/actors/poisonBomb-idle.png");
    var& SDL_Open_Image img_destroy      = spawn SDL_Open_Image(&outer.renderer, "assets/img/actors/poisonBomb-destroy.png");

    var IImage_Quad iq_idle    = val IImage_Quad( &img_idle,     sprite_size, _ );
    var IImage_Quad iq_destroy   = val IImage_Quad( &img_destroy,    sprite_size, _ );

    var IAnimation ianim_idle      = val IAnimation( iq_idle,       sprite_offset, 16 );
    var IAnimation ianim_destroy     = val IAnimation( iq_destroy,      sprite_offset, 16 );

    ip_bomb.imov_obj.aabb.rotate_angle = (_rand()%360);
    var real gravity = 80;
	par/or do
        every 50ms do
            ip_bomb.imov_obj.aabb.rotate_angle = ip_bomb.imov_obj.aabb.rotate_angle + 5;
            if ip_bomb.imov_obj.aabb.rotate_angle > 360 then
                ip_bomb.imov_obj.aabb.rotate_angle = 0;
            end
        end
    with            
        loop do
            await Animation (&ianim_idle, &ip_bomb.imov_obj.aabb.center, &ip_bomb.imov_obj.aabb.scale, &ip_bomb.imov_obj.aabb.rotate_angle );
        end
    with
		var int dt;
		every dt in SDL_DT do
			ip_bomb.imov_obj.speed.y = ip_bomb.imov_obj.speed.y + (gravity * dt/1000);
            if call Off_Screen(&ip_bomb) then
                break;
            end
        end
    with
        var int interval = 150;
        var int r = 255;
        var int g = 255;
        var int b = 255;
        var IVector scale_var = val IVector (0.1, 0.1);
        await 1s;
        loop _ in [1->2] do
            loop _ in [1 -> 3] do
                g = g - 32;
                b = b - 32;
                ip_bomb.imov_obj.aabb.scale = call Vec_Add( ip_bomb.imov_obj.aabb.scale, scale_var );
                _SDL_SetTextureColorMod(&&iq_idle.img.tex.tex, r, g, b);
                await (interval)ms;
            end
            loop _ in [1 -> 3] do
                g = g + 32;
                b = b + 32;
                ip_bomb.imov_obj.aabb.scale = call Vec_Sub( ip_bomb.imov_obj.aabb.scale, scale_var );
                _SDL_SetTextureColorMod(&&iq_idle.img.tex.tex, r, g, b);
                await (interval)ms;
            end
        end
    with
        await ip_bomb.hit;
        await 100ms;
    end
    ip_bomb.imov_obj.destroyed = true;
    ip_bomb.imov_obj.speed = ip_bomb.imap.speed;
    ip_bomb.imov_obj.aabb.rotate_angle = 0;
    await Animation (&ianim_destroy, &ip_bomb.imov_obj.aabb.center, &ip_bomb.imov_obj.aabb.scale, &ip_bomb.imov_obj.aabb.rotate_angle );
    var ITile.IPoison_Cloud p_cloud = call Create_Poison_Cloud(ip_bomb.imov_obj.aabb.center, ip_bomb.imap.speed);
    var&? Tile tile = spawn/dynamic Tile(&p_cloud) in ip_bomb.imap.all_tiles;
    await tile;
end

code/await/dynamic Actor ( var&/dynamic IActor.IPoison_Bomb iact )
    -> ( var IActor.IPoison_Bomb iactor = iact )
         -> none
do
    await Poison_Bomb(&iactor);
end

code/await/dynamic Hit_Actor (var&/dynamic IActor.IPoison_Bomb hitman, var&/dynamic IActor.IPlayer hitted) -> none
do

end