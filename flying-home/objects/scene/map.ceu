data IMap with
    var IVector position;
    var IVector size;
    var IVector tile_size;
    var IVector speed;
    var&[] int tile_map;
    pool&[] Tile all_tiles;
    pool&[] Actor all_actors;
end

code/call Get_Index_By_Pos (var& IMap imap, var IVector position) -> int
do
    var real x = position.x / imap.tile_size.x;
    var real y = position.y / imap.tile_size.y;
    escape (x + (y * imap.size.x)) as int;
end

code/call Get_Pos_By_Index (var& IMap imap, var int ind ) -> IVector
do
    var int x           = ind % (imap.size.x as int);
    var int y           = ((ind - x) / imap.size.x) as int;
    var IVector position = val IVector((x * imap.tile_size.x) + imap.position.x + (imap.tile_size.x/2), (y * imap.tile_size.y) + imap.position.y + (imap.tile_size.y/2));
    escape position;
end

code/call Get_Pos_By_Index_Pos (var& IMap imap, var int x, var int y ) -> IVector
do
    var IVector position = val IVector((x * imap.tile_size.x) + imap.position.x + (imap.tile_size.x/2), (y * imap.tile_size.y) + imap.position.y + (imap.tile_size.y/2));
    escape position;
end

code/await Map ( var& IMap imap )
            -> ( var& IMap blue_sky = &imap )
                -> NEVER
do
    var int dt;
    every dt in SDL_DT do
        var real speed_x = ((imap.speed.x * dt)/1000);
        var real speed_y = ((imap.speed.y * dt)/1000);
        imap.position.x = imap.position.x + (speed_x);
        imap.position.y = imap.position.y + (speed_y);
    end
end 