#include "tools/animation.ceu"

code/await Character (var int x, var int y, var int w, var int h, var& _SDL_Renderer ren) -> none
do
    var& SDL_Open_Image img_backward =
        spawn SDL_Open_Image(&ren, "assets/img/char/walker-backward.png");
    var& SDL_Open_Image img_dead =
        spawn SDL_Open_Image(&ren, "assets/img/char/walker-dead.png");
    var& SDL_Open_Image img_dive =
        spawn SDL_Open_Image(&ren, "assets/img/char/walker-dive.png");
    var& SDL_Open_Image img_flying =
        spawn SDL_Open_Image(&ren, "assets/img/char/walker-fly.png");
    var& SDL_Open_Image img_foward =
        spawn SDL_Open_Image(&ren, "assets/img/char/walker-foward.png");
    var& SDL_Open_Image img_glide =
        spawn SDL_Open_Image(&ren, "assets/img/char/walker-glide.png");

    var SDL_Rect char_rect = val SDL_Rect(x, y, w, h);
    var real flying_speed = 100;
    var real foward_speed = 100;
    var real backward_speed = -100;
    var real normal_speed = 50;
    var real gravity = 50;

    code/await State(var real horiz_speed, var real vert_speed, var& SDL_Open_Image img) -> none
    do
        var& SDL_Rect c_rect = &outer.char_rect;
        par do
            await Animation (32, 32, 8, &c_rect, &outer.ren, &img);
        with    
            var int dt;
            every dt in SDL_DT do
                var real x_speed = ((horiz_speed * dt)/1000);
                var real y_speed = ((vert_speed * dt)/1000);
                c_rect.x = c_rect.x + (x_speed as int);
                c_rect.y = c_rect.y + (y_speed as int);
            end
        end
    end

    code/await Glide (none) -> none
    do
        par/or do
            await State(outer.normal_speed, outer.gravity, &outer.img_glide);
        with            
            loop do
                var u8&& key_state = _SDL_GetKeyboardState(null);
                if key_state[_SDL_SCANCODE_A] != key_state[_SDL_SCANCODE_D] then
                    break;
                end
                var _SDL_KeyboardEvent&& key = await SDL_KEYDOWN until (key:keysym.sym == _SDLK_a 
                                                                    or key:keysym.sym == _SDLK_d);
            end
        end
    end

    code/await Foward_Backward(none) -> none
    do
        var u8&& key_state = _SDL_GetKeyboardState(null);
        var& SDL_Open_Image img;
        var real x_speed;
        if key_state[_SDL_SCANCODE_A] == 1 then
            x_speed = outer.backward_speed;
            img = &outer.img_backward;
        else
            x_speed = outer.foward_speed;
            img = &outer.img_foward;
        end
        par/or do
            await State(x_speed, outer.gravity, &img);
        with
            loop do
                var u8&& key_state = _SDL_GetKeyboardState(null);
                if key_state[_SDL_SCANCODE_A] == key_state[_SDL_SCANCODE_D] then
                    break;
                end
                var _SDL_KeyboardEvent&& key = await SDL_KEYDOWN until (key:keysym.sym == _SDLK_a 
                                                                    or key:keysym.sym == _SDLK_d);
            end
        with
            var _SDL_KeyboardEvent&& key = await SDL_KEYUP until (key:keysym.sym == _SDLK_a 
                                                                or key:keysym.sym == _SDLK_d);
        end
    end

    code/await Fly_Dive (none) -> none
    do
        var u8&& key_state = _SDL_GetKeyboardState(null);
        var& SDL_Open_Image img;        
        var& SDL_Rect c_rect = &outer.char_rect;
        var real vert_speed;

        if key_state[_SDL_SCANCODE_S] == 1 then
            vert_speed = outer.flying_speed;
            img = &outer.img_dive;
        else
            vert_speed = -(outer.flying_speed);
            img = &outer.img_flying;
        end
        par/or do
            par do
                await Animation (32, 32, 8, &outer.char_rect, &outer.ren, &img);
            with    
                var int dt;
                every dt in SDL_DT do  
                    var real x_speed;
                    var real y_speed;
                    var u8&& key_state = _SDL_GetKeyboardState(null);
                    if key_state[_SDL_SCANCODE_A] != key_state[_SDL_SCANCODE_D] then
                        if key_state[_SDL_SCANCODE_A] == 1 then
                            x_speed = outer.backward_speed;
                        else
                            x_speed = outer.foward_speed;
                        end
                    else
                        x_speed = outer.normal_speed;
                    end
                    y_speed = ((vert_speed * dt)/1000);
                    x_speed = ((x_speed * dt)/1000);
                    c_rect.x = c_rect.x + (x_speed as int);
                    c_rect.y = c_rect.y + (y_speed as int);
                end
            end
        with
            loop do
                var u8&& key_state = _SDL_GetKeyboardState(null);
                if key_state[_SDL_SCANCODE_W] == key_state[_SDL_SCANCODE_S] then
                    break;
                end
                var _SDL_KeyboardEvent&& key = await SDL_KEYDOWN until (key:keysym.sym == _SDLK_w 
                                                                    or key:keysym.sym == _SDLK_s);
            end
        with
            var _SDL_KeyboardEvent&& key = await SDL_KEYUP until (key:keysym.sym == _SDLK_w
                                                                or key:keysym.sym == _SDLK_s);
        end
    end


    loop do
        par/or do
            await Glide();
            await Foward_Backward();
            continue;
        with
            loop do
                var u8&& key_state = _SDL_GetKeyboardState(null);
                if key_state[_SDL_SCANCODE_W] != key_state[_SDL_SCANCODE_S] then
                    break;
                end
                var _SDL_KeyboardEvent&& key = await SDL_KEYDOWN until (key:keysym.sym == _SDLK_w 
                                                                    or key:keysym.sym == _SDLK_s);
            end

        end
        await Fly_Dive();
    end

end
