code/await Cloud_Idle_Animation (var& _SDL_Renderer ren) 
		-> (var SDL_Rect frame, var& SDL_Open_Image img_cloud_idle, event none close_animation)
			-> NEVER
do
	img_cloud_idle = spawn SDL_Open_Image(&ren, "assets/img/clouds/smallCloud-idle.png");

	frame = val SDL_Rect(0, 0, 32, 32);
	var int anim_fps = 2;
	par/or do
		every (1000/anim_fps)ms do
		    frame.x = frame.x + frame.w;
		    if frame.x >= img_cloud_idle.tex.width then
		        frame.x = 0;
		        frame.y = frame.y + frame.h;
		        if frame.y >= img_cloud_idle.tex.height then
		            frame.y = 0;
		        end
		    end
		end
	with
		await close_animation;
	end
end

code/await Cloud (var& SDL_Rect speed, var int x, var int y, var& Cloud_Idle_Animation anim, var& _SDL_Renderer ren) 
			-> (event none go_collided, var SDL_Rect rect = val SDL_Rect(x, y, 64, 64)) 
					-> none
do		
    var& SDL_Open_Image img_cloud_destroy =
        spawn SDL_Open_Image(&ren, "assets/img/clouds/smallCloud-destroy.png");

    par/or do
    	par/or do
        	every SDL_REDRAW do
        		if rect.x < 1024 and rect.x > -rect.w then
        			_SDL_RenderCopy(&&ren, &&anim.img_cloud_idle.tex.tex, &&anim.frame as _SDL_Rect&&, &&rect as _SDL_Rect&&);
        		end
        	end
		with 
			await go_collided;
		end		
		await Animation (32, 32, 12, &rect, &ren, &img_cloud_destroy);
	with
        var int dt;
        every dt in SDL_DT do
            var real speed_x = ((speed.x * dt)/1000);
            var real speed_y = ((speed.y * dt)/1000);
            rect.x = rect.x + (speed_x as int);
            rect.y = rect.y + (speed_y as int);
        end
	end	
end