code/await Cloud_Manager (var& Map map, var int cloud_index, var& _SDL_Renderer ren) -> NEVER
do
    event int create_tile_column;

    var Vector position         = val Vector (0, 0);
    var Vector size             = val Vector (28, 28);
    var Vector sprite_size      = val Vector (map.tile_size.x, map.tile_size.x);
    var Vector sprite_offset    = val Vector (sprite_size.x/2, sprite_size.y/2);
    var Vector scale            = val Vector (1, 1);

    var& SDL_Open_Image img_cloud_idle      = spawn SDL_Open_Image(&ren, "assets/img/clouds/smallCloud-idle.png");
    var& SDL_Open_Image img_cloud_destroy   = spawn SDL_Open_Image(&ren, "assets/img/clouds/smallCloud-destroy.png");
    var Image_Quad iq_cloud_idle            = val Image_Quad(&ren, &img_cloud_idle, &sprite_size, _);
    var Image_Quad iq_cloud_destroy         = val Image_Quad(&ren, &img_cloud_destroy, &sprite_size, _);
    var& Loop_Animation cl_anim             = spawn Loop_Animation(&iq_cloud_idle, &position, &scale, &sprite_offset, 2);
    emit cl_anim.pause_draw(true);

        code/await Cloud (var Vector pst) 
                    -> (event none go_collided, var Aabb aabb = val Aabb(pst, call Vec_ScaDiv(outer.size, 2)),
                        var& Vector position = &aabb.center, var bool destroyed = false) 
                            -> none
        do
            var Vector scale = outer.scale;
            var Vector speed = val Vector (0, 0);

            par/or do
                par/or do
                    every SDL_REDRAW do
                        if position.x < 544 and position.x > -outer.sprite_size.x then
                            call Draw(&outer.iq_cloud_idle, position.x, position.y, scale.x, scale.y, outer.sprite_offset.x, outer.sprite_offset.y);
                        end
                        var int x = (aabb.center.x - aabb.half_size.x) as int;
                        var int y = (aabb.center.y - aabb.half_size.y) as int;
                        var int w = (aabb.half_size.x * 2) as int;
                        var int h = (aabb.half_size.y * 2) as int;

                        var SDL_Rect rect = val SDL_Rect(x, y, w, h);
                        _SDL_SetRenderDrawColor(&&outer.ren, 0x2D, 0x51, 0x71, 0xFF);
                        _SDL_RenderDrawRect(&&outer.ren, &&rect as _SDL_Rect&&);
                    end
                with 
                    await go_collided;
                    destroyed = true;
                end     
                await Animation (outer.iq_cloud_destroy, &position, &scale, &outer.sprite_offset, 10);
            with
                var int dt;
                every dt in SDL_DT do
                    var real speed_x = ((outer.map.map_speed.x * dt)/1000);
                    var real speed_y = ((speed.y * dt)/1000);
                    position.x = position.x + (speed_x as int);
                    position.y = position.y + (speed_y as int);
                end
            end 
        end

    pool[] Cloud level_clouds;

    spawn do
        var int x;
        every x in create_tile_column do
            if x < map.tile_map.w then
                var int j;
                loop j in [0 -> map.tile_map.h - 1] do
                    var int index = x + (j * map.tile_map.w);
                    if map.tile_objs[index] == cloud_index then
                        var Vector create_position = call map.Get_Pos_By_Index( index );
                        create_position.x = create_position.x + 544;
                        spawn Cloud( create_position ) in level_clouds;
                    end
                end
            end
        end
    end


    var int dt;
    var int column = 0;
    every dt in SDL_DT do
        if ((-map.tile_map.x/map.tile_size.x) as int) != column then
            emit create_tile_column(column);
            column = (-map.tile_map.x/map.tile_size.x) as int;
        end
        var&? Cloud cld;    
        loop cld in level_clouds do
            if (call Overlaps(&cld!.aabb, &map.player!.aabb)) then
                if cld!.destroyed == false then
                    call map.player!.Hit(1);
                    emit cld!.go_collided;
                end
            end
        end
    end
end