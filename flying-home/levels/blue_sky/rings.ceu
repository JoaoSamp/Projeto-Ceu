code/await Ring_Manager (var& Map map, var int ring_index, var& _SDL_Renderer ren) -> NEVER
do
    event int create_tile_column;

    var Vector position         = val Vector (0, 0);
    var Vector size             = val Vector (28, 28);
    var Vector sprite_size      = val Vector (map.tile_size.x, map.tile_size.x);
    var Vector sprite_offset    = val Vector (sprite_size.x/2, sprite_size.y/2);
    var Vector scale            = val Vector (1, 1);

    var& SDL_Open_Image img_ring_idle       = spawn SDL_Open_Image(&ren, "assets/img/items/smallRing-idle.png");
    var& SDL_Open_Image img_ring_destroy    = spawn SDL_Open_Image(&ren, "assets/img/items/smallRing-destroy.png");
    var Image_Quad iq_ring_idle             = val Image_Quad(&ren, &img_ring_idle, &sprite_size, _);
    var Image_Quad iq_ring_destroy          = val Image_Quad(&ren, &img_ring_destroy, &sprite_size, _);
    var& Loop_Animation cl_anim             = spawn Loop_Animation(&iq_ring_idle, &position, &scale, &sprite_offset, 12);
    emit cl_anim.pause_draw(true);

        code/await Ring (var Vector pst) 
                    ->  (event none go_collided, var Aabb aabb = val Aabb(pst, call Vec_ScaDiv(outer.size, 2)),
                        var& Vector position = &aabb.center, var bool destroyed = false) 
                            -> none
        do      
            var Vector scale = outer.scale;
            var Vector speed = val Vector (0, 0);

            par/or do
                par/or do
                    every SDL_REDRAW do
                        if position.x < 544 and position.x > -outer.sprite_size.x then
                            call Draw(&outer.iq_ring_idle, position.x, position.y, scale.x, scale.y, outer.sprite_offset.x, outer.sprite_offset.y);
                        end
                    end
                with 
                    await go_collided;
                    destroyed = true;
                end     
                await Animation (outer.iq_ring_destroy, &position, &scale, &outer.sprite_offset, 10);
            with
                var int dt;
                every dt in SDL_DT do
                    var real speed_x = ((outer.map.map_speed.x * dt)/1000);
                    var real speed_y = ((speed.y * dt)/1000);
                    position.x = position.x + (speed_x as int);
                    position.y = position.y + (speed_y as int);
                end
            end 
        end

    pool[] Ring level_rings;

    spawn do
        var int x;
        every x in create_tile_column do
            if x < map.tile_map.w then
                var int j;
                loop j in [0 -> map.tile_map.h - 1] do
                    var int index = x + (j * map.tile_map.w);
                    if map.tile_objs[index] == ring_index then
                        var Vector create_position = call map.Get_Pos_By_Index( index );
                        create_position.x = create_position.x + 544;
                        spawn Ring( create_position ) in level_rings;
                    end
                end
            end
        end
    end

    var int dt;
    var int column = 0;
    every dt in SDL_DT do
        if ((-map.tile_map.x/map.tile_size.x) as int) != column then
            emit create_tile_column(column);
            column = (-map.tile_map.x/map.tile_size.x) as int;
        end
        var&? Ring rng;    
        loop rng in level_rings do
            if (call Overlaps(&rng!.aabb, &map.player!.aabb)) then
                if rng!.destroyed == false then
                    call map.player!.Recover(2);
                    emit rng!.go_collided;
                end
            end
        end
    end
end