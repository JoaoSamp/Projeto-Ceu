data IMoving_Obj with
	var IAABBox aabb;
	var IVector position;
	var IVector old_position;
	var IVector max_speed 		= val IVector(80, 80);
	var IVector speed 			= val IVector(0, 0);
	var IVector acceleration 	= val IVector(0, 0);

	var bool bound_top		= true;
	var bool bound_bottom	= true;
	var bool bound_left 	= true;
	var bool bound_right	= true;

	var bool pushesTop 		= false;
	var bool pushesBottom 	= false;
	var bool pushesRight 	= false;
	var bool pushesLeft 	= false;

	var bool pushedTop		= false;
	var bool pushedBottom	= false;
	var bool pushedRight	= false;
	var bool pushedLeft		= false;

	var bool destroyed = false;
end

code/call Create_Moving_Obj (var IVector position, var IVector size) -> IMoving_Obj
do
	var IAABBox aabb = val IAABBox(position, call Vec_ScaDiv(size, 2), _, _);
	var IMoving_Obj imov_obj = val IMoving_Obj (aabb, position, position, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _);
	escape imov_obj;	
end

code/call Update_Physics (var& IMoving_Obj imov_obj, var int dt) -> none
do
	imov_obj.speed.x = (imov_obj.speed.x + (imov_obj.acceleration.x * dt/1000)) * 0.9;
	imov_obj.speed.y = (imov_obj.speed.y + (imov_obj.acceleration.y * dt/1000)) * 0.9;

	if imov_obj.speed.x > imov_obj.max_speed.x then
		imov_obj.speed.x = imov_obj.max_speed.x;
	else/if imov_obj.speed.x < -imov_obj.max_speed.x then
		imov_obj.speed.x = -imov_obj.max_speed.x;
	end

	if imov_obj.speed.y > imov_obj.max_speed.y then
		imov_obj.speed.y = imov_obj.max_speed.y;
	else/if imov_obj.speed.y < -imov_obj.max_speed.y then
		imov_obj.speed.y = -imov_obj.max_speed.y;
	end

    var real speed_x = imov_obj.speed.x * dt/1000;
    var real speed_y = imov_obj.speed.y * dt/1000;

    imov_obj.old_position = imov_obj.position;
    imov_obj.position.x = (imov_obj.position.x + speed_x);
    imov_obj.position.y = (imov_obj.position.y + speed_y);

    imov_obj.aabb.center = imov_obj.position;
end