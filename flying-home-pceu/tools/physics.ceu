code/call Check_Bot_Collision(var& IMoving_Obj imov_obj, var& IMap imap) -> int
do
    var IVector half_size       = call AABB_Get_Half_Size(&imov_obj.iaabb);
    var real old_bottom         = imov_obj.ikinematic.old_position.y - half_size.y - 1;
    var IVector old_bot_left    = call VRound( IVector (imov_obj.ikinematic.old_position.x - half_size.x + 1, old_bottom), 1);

    var real new_bottom             = imov_obj.ikinematic.position.y - half_size.y - 1;
    var IVector new_bot_left       = call VRound( IVector(imov_obj.ikinematic.position.x - half_size.x + 1, new_bottom), 1);
    var IVector new_bot_right      = call VRound( IVector(imov_obj.ikinematic.position.x + half_size.x - 1, new_bottom), 1);

    var int end_y       = call Get_Y_Index_By_Y_Pos( &imap, new_bottom );
    var int beg_y       = _fmax( call Get_Y_Index_By_Y_Pos( &imap, old_bottom ) - 1, end_y) as int;
    var real distance   = _fmax( _fabs(end_y - beg_y), 1 );
    
    var int tile_index_y;
    loop tile_index_y in [end_y <- beg_y] do
        var real partial_distance   = _fmax( _fabs(tile_index_y - beg_y), 1 );
        var IVector bottom_left     = call VLerp ( new_bot_left, old_bot_left, partial_distance/distance );
        var real bottom             = bottom_left.y;
        var real left               = bottom_left.x;
        var real right              = bottom_left.x + (half_size.x * 2) - 2;
        loop do
            var IVector position = val IVector(left, bottom);
            var int index = call Get_Index_By_Relative_Pos (&imap, position);
            if index > 0 and index < $imap.tile_map then
                if imap.tile_map[index] != 0 then
                    escape index;
                end
            end
            if left >= right then
                escape -1;
            end

            left = _fmin(left + imap.tile_size.x, right);
        end
    end
end

code/call Check_Top_Collision(var& IMoving_Obj imov_obj, var& IMap imap) -> int
do
    var IVector half_size       = call AABB_Get_Half_Size( &imov_obj.iaabb );
    var real old_top            = imov_obj.ikinematic.old_position.y + half_size.y + 1;
    var IVector old_top_left    = call VRound( IVector ( imov_obj.ikinematic.old_position.x - half_size.x + 1, old_top ), 1);

    var real new_top            = imov_obj.ikinematic.position.y + half_size.y + 1;
    var IVector new_top_left    = call VRound( IVector(imov_obj.ikinematic.position.x - half_size.x + 1, new_top), 1);
    var IVector new_top_right   = call VRound( IVector(imov_obj.ikinematic.position.x + half_size.x - 1, new_top), 1);

    var int end_y       = call Get_Y_Index_By_Y_Pos( &imap, new_top );
    var int beg_y       = _fmin( call Get_Y_Index_By_Y_Pos( &imap, old_top ) + 1, end_y) as int;
    var real distance   = _fmax( _fabs(end_y - beg_y), 1 );
    
    var int tile_index_y;
    loop tile_index_y in [beg_y -> end_y] do
        var real partial_distance   = _fmax( _fabs(tile_index_y - beg_y), 1 );
        var IVector top_left        = call VLerp ( new_top_left, old_top_left, partial_distance/distance );
        var real top                = top_left.y;
        var real left               = top_left.x;
        var real right              = top_left.x + (half_size.x * 2) - 2;

        loop do
            var IVector position = val IVector(left, top);
            var int index = call Get_Index_By_Relative_Pos (&imap, position);
            if index > 0 and index < $imap.tile_map then
                if imap.tile_map[index] != 0 then
                    escape index;
                end
            end
            if left >= right then
                escape -1;
            end

            left = _fmin(left + imap.tile_size.x, right);
        end
    end
end

code/call Check_Left_Collision(var& IMoving_Obj imov_obj, var& IMap imap) -> int
do
    var IVector half_size       = call AABB_Get_Half_Size( &imov_obj.iaabb );
    var real old_left           = imov_obj.ikinematic.old_position.x - half_size.x - 1;
    var IVector old_bot_left    = call VRound( IVector ( old_left, imov_obj.ikinematic.old_position.y - half_size.y ), 1);

    var real new_left           = imov_obj.ikinematic.position.x - half_size.x - 1;
    var IVector new_bot_left    = call VRound( IVector( new_left, imov_obj.ikinematic.position.y - half_size.y), 1);
    var IVector new_top_left    = call VRound( IVector( new_left, imov_obj.ikinematic.position.y + half_size.y), 1);

    var int end_x       = call Get_X_Index_By_X_Pos( &imap, new_left );
    var int beg_x       = _fmax( call Get_X_Index_By_X_Pos( &imap, old_left ) + 1, end_x) as int;
    var real distance   = _fmax( _fabs(end_x - beg_x), 1 );
    
    var int tile_index_x;
    loop tile_index_x in [end_x <- beg_x] do
        var real partial_distance   = _fmax( _fabs(tile_index_x - beg_x), 1 );
        var IVector bot_left        = call VLerp ( new_bot_left, old_bot_left, partial_distance/distance );
        var real left               = bot_left.x;
        var real bot                = bot_left.y;
        var real top                = bot_left.y + (half_size.x * 2);

        loop do
            var IVector position = val IVector(left, bot);
            var int index = call Get_Index_By_Relative_Pos (&imap, position);
            if index > 0 and index < $imap.tile_map then
                if imap.tile_map[index] != 0 then
                    escape index;
                end
            end
            if bot >= top then
                escape -1;
            end

            bot = _fmin(bot + imap.tile_size.x, top);
        end
    end
end

code/call Check_Right_Collision(var& IMoving_Obj imov_obj, var& IMap imap) -> int
do
    var IVector half_size       = call AABB_Get_Half_Size( &imov_obj.iaabb );
    var real old_right          = imov_obj.ikinematic.old_position.x + half_size.x + 1;
    var IVector old_bot_right   = call VRound( IVector ( old_right, imov_obj.ikinematic.old_position.y - half_size.y ), 1);

    var real new_right          = imov_obj.ikinematic.position.x + half_size.x + 1;
    var IVector new_bot_right   = call VRound( IVector( new_right, imov_obj.ikinematic.position.y - half_size.y), 1);
    var IVector new_top_right   = call VRound( IVector( new_right, imov_obj.ikinematic.position.y + half_size.y), 1);

    var int end_x       = call Get_X_Index_By_X_Pos( &imap, new_right );
    var int beg_x       = _fmin( call Get_X_Index_By_X_Pos( &imap, old_right ) + 1, end_x) as int;
    var real distance   = _fmax( _fabs(end_x - beg_x), 1 );
    
    var int tile_index_x;
    loop tile_index_x in [beg_x -> end_x] do
        var real partial_distance   = _fmax( _fabs(tile_index_x - beg_x), 1 );
        var IVector bot_right       = call VLerp ( new_bot_right, old_bot_right, partial_distance/distance );
        var real right              = bot_right.x;
        var real bot                = bot_right.y;
        var real top                = bot_right.y + (half_size.x * 2);

        loop do
            var IVector position = val IVector(right, bot);
            var int index = call Get_Index_By_Relative_Pos (&imap, position);
            if index > 0 and index < $imap.tile_map then
                if imap.tile_map[index] != 0 then
                    escape index;
                end
            end
            if bot >= top then
                escape -1;
            end

            bot = _fmin(bot + imap.tile_size.x, top);
        end
    end
end

code/await Update_Actors (pool&[] Actor actors, pool&[] Tile tiles, var& IMap imap) -> NEVER
do
    var int dt;
    every dt in FRAMES_UPDATE do
        var&? Actor actor;
        loop actor in actors do
            var IMoving_Obj imov_obj        = actor!.iactor.imov_obj;
            var IVector half_size           = call AABB_Get_Half_Size(&imov_obj.iaabb);
            
            // Update restraints
            imov_obj.pushed_top     = imov_obj.pushes_top;
            imov_obj.pushed_bottom  = imov_obj.pushes_bottom;
            imov_obj.pushed_left    = imov_obj.pushes_left;
            imov_obj.pushed_right   = imov_obj.pushes_right;
            imov_obj.pushes_top     = false;
            imov_obj.pushes_bottom  = false;
            imov_obj.pushes_left    = false;
            imov_obj.pushes_right   = false;

            imov_obj.pushed_top_tile     = imov_obj.pushes_top_tile;
            imov_obj.pushed_bottom_tile  = imov_obj.pushes_bottom_tile;
            imov_obj.pushed_left_tile    = imov_obj.pushes_left_tile;
            imov_obj.pushed_right_tile   = imov_obj.pushes_right_tile;
            imov_obj.pushes_bottom_tile  = false;
            imov_obj.pushes_top_tile     = false;
            imov_obj.pushes_left_tile    = false;
            imov_obj.pushes_right_tile   = false;

            // Update velocity and check restraints
            call Kinematic_Update_Velocity( &imov_obj.ikinematic, &imov_obj.isteering, dt );
            if imov_obj.pushed_top_tile or imov_obj.pushed_top then
                imov_obj.ikinematic.velocity.y = _fmin(imov_obj.ikinematic.velocity.y, 0);
            end
            if imov_obj.pushed_bottom_tile or imov_obj.pushed_bottom then
                imov_obj.ikinematic.velocity.y = _fmax(imov_obj.ikinematic.velocity.y, 0);
            end
            if imov_obj.pushed_left_tile or imov_obj.pushed_left then
                imov_obj.ikinematic.velocity.x = _fmax(imov_obj.ikinematic.velocity.x, 0);
            end
            if imov_obj.pushed_right_tile or imov_obj.pushed_right then
                imov_obj.ikinematic.velocity.x = _fmin(imov_obj.ikinematic.velocity.x, 0);
            end

            call Kinematic_Update_Position ( &imov_obj.ikinematic, dt );
            imov_obj.iaabb.center = imov_obj.ikinematic.position;

            if imov_obj.ikinematic.velocity.x >= 0 then
                var int right_collision_index = call Check_Right_Collision( &imov_obj, &imap );
                if right_collision_index > 0 then
                    var&? Tile tile;
                    loop tile in tiles do
                        if tile!.itile.id == imap.tile_map[right_collision_index] then
                            var IAABBox tile_iaabb = val IAABBox (call Get_Pos_By_Index( &imap, right_collision_index ), call VMultSca(tile!.itile.size, 0.5), IVector(1,1), 0);
                            if call Overlaps( &tile_iaabb, &imov_obj.iaabb ) then
                                if tile!.itile.body_type is BType.Solid then
                                    var int right_position = _round(tile_iaabb.center.x - tile_iaabb.half_size.x - half_size.x) as int;
                                    if  (_round(imov_obj.ikinematic.old_position.x) as int) <= right_position then
                                        imov_obj.ikinematic.position.x  = right_position;
                                        imov_obj.ikinematic.velocity.x  = 0;
                                        imov_obj.pushes_right_tile     = true;
                                    end
                                end
                                var ITile_Collision it_collision        = call/dynamic Tile_Hit (&actor!.iactor, &tile!.itile, right_collision_index);
                                if it_collision.collision then
                                    emit tile!.itile.collision(right_collision_index);
                                end
                            end
                            break;
                        end
                    end
                end
            end
            if imov_obj.ikinematic.velocity.x <= 0 then
                var int left_collision_index = call Check_Left_Collision( &imov_obj, &imap );
                if left_collision_index > 0 then
                    var&? Tile tile;
                    loop tile in tiles do
                        if tile!.itile.id == imap.tile_map[left_collision_index] then
                            var IAABBox tile_iaabb = val IAABBox (call Get_Pos_By_Index( &imap, left_collision_index ), call VMultSca(tile!.itile.size, 0.5), IVector(1,1), 0);                                
                            if call Overlaps( &tile_iaabb, &imov_obj.iaabb ) then
                                if tile!.itile.body_type is BType.Solid then
                                    var int left_position = _round(tile_iaabb.center.x + tile_iaabb.half_size.x + half_size.x) as int;
                                    if  (_round(imov_obj.ikinematic.old_position.x) as int) >= left_position then
                                        imov_obj.ikinematic.position.x  = left_position;
                                        imov_obj.ikinematic.velocity.x  = 0;
                                        imov_obj.pushes_left_tile     = true;
                                    end
                                end
                                var ITile_Collision it_collision        = call/dynamic Tile_Hit (&actor!.iactor, &tile!.itile, left_collision_index);
                                if it_collision.collision then
                                    emit tile!.itile.collision(left_collision_index);
                                end
                            end
                            break;
                        end
                    end
                end
            end

            if imov_obj.ikinematic.velocity.y <= 0 then
                var int bot_collision_index = call Check_Bot_Collision( &imov_obj, &imap );
                if bot_collision_index > 0 then
                    var&? Tile tile;
                    loop tile in tiles do
                        if tile!.itile.id == imap.tile_map[bot_collision_index] then
                            var IAABBox tile_iaabb = val IAABBox (call Get_Pos_By_Index( &imap, bot_collision_index ), call VMultSca(tile!.itile.size, 0.5), IVector(1,1), 0);                                
                            if call Overlaps( &tile_iaabb, &imov_obj.iaabb ) then
                                if tile!.itile.body_type is BType.Solid then
                                    imov_obj.ikinematic.position.y  = tile_iaabb.center.y + tile_iaabb.half_size.y + half_size.y + 1;
                                    imov_obj.ikinematic.velocity.y  = 0;
                                    imov_obj.pushes_bottom_tile     = true;
                                end
                                var ITile_Collision it_collision        = call/dynamic Tile_Hit (&actor!.iactor, &tile!.itile, bot_collision_index);
                                if it_collision.collision then
                                    emit tile!.itile.collision(bot_collision_index);
                                end
                            end
                            break;
                        end
                    end
                end
            end

            if imov_obj.ikinematic.velocity.y >= 0 then
                var int top_collision_index = call Check_Top_Collision( &imov_obj, &imap );
                if top_collision_index > 0 then
                    var&? Tile tile;
                    loop tile in tiles do
                        if tile!.itile.id == imap.tile_map[top_collision_index] then
                            var IAABBox tile_iaabb = val IAABBox (call Get_Pos_By_Index( &imap, top_collision_index ), call VMultSca(tile!.itile.size, 0.5), IVector(1,1), 0);                                
                            if call Overlaps( &tile_iaabb, &imov_obj.iaabb ) then
                                if tile!.itile.body_type is BType.Solid then
                                    imov_obj.ikinematic.position.y  = tile_iaabb.center.y - tile_iaabb.half_size.y - half_size.y - 1;
                                    imov_obj.ikinematic.velocity.y  = 0;
                                    imov_obj.pushes_top_tile     = true;
                                end
                                var ITile_Collision it_collision        = call/dynamic Tile_Hit (&actor!.iactor, &tile!.itile, top_collision_index);
                                if it_collision.collision then
                                    emit tile!.itile.collision(top_collision_index);
                                end
                            end
                            break;
                        end
                    end
                end
            end

            var IVector map_boundaries  = call Get_Map_Y_Boundaries (&imap);

            if imov_obj.ikinematic.position.y + half_size.y > map_boundaries.x then
                if imov_obj.iboundaries.bound_top then
                    imov_obj.ikinematic.position.y  = map_boundaries.x - half_size.y;
                    imov_obj.ikinematic.velocity.y  = 0;
                    imov_obj.pushes_top_tile        = true;
                end
            else/if imov_obj.ikinematic.position.y - half_size.y < map_boundaries.y then
                if imov_obj.iboundaries.bound_bottom then
                    imov_obj.ikinematic.position.y  = map_boundaries.y + half_size.y;
                    imov_obj.ikinematic.velocity.y  = 0;
                    imov_obj.pushes_bottom_tile     = true;
                end
            end

            var IVector camera_size = call Camera_Get_Size();
            var IVector camera_bounds_x = call Camera_Get_Boundaries_X();

            if imov_obj.ikinematic.position.x - half_size.x < camera_bounds_x.x then
                if imov_obj.iboundaries.bound_left then
                    imov_obj.ikinematic.position.x  = camera_bounds_x.x + half_size.x;
                    imov_obj.pushes_left_tile       = true;
                end
            else/if imov_obj.ikinematic.position.x + half_size.x > camera_bounds_x.y then
                if imov_obj.iboundaries.bound_right then
                    imov_obj.ikinematic.position.x  = camera_bounds_x.y - half_size.x;
                    imov_obj.pushes_right_tile      = true;
                end
            end

            var&? Actor other_actor;
            loop other_actor in actors do
                if &&actor!.iactor != &&other_actor!.iactor then
                    var IActor_Collision collision = call/dynamic Actor_Hit(&actor!.iactor, &other_actor!.iactor);
                    if collision.target_data.hit then
                        //emit other_actor!.iactor.hit ();
                        //emit actor!.iactor.hit ();
                    end
                end
            end
            if actor? then
                imov_obj.iaabb.center = imov_obj.ikinematic.position;
                actor!.iactor.imov_obj = imov_obj;
            end
        end
    end
end 
