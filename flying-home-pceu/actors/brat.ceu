data IActor.IEnemie.IBrat with
    var IStatus_Component istatus;
    var& IActor itarget;
end;

code/call Create_Brat (var& IActor itarget ) -> IActor.IEnemie.IBrat
do
    var int max_life = 15;
    var IVector start_pos               = val IVector(160, 100);
    var IStatus_Component istatus       = call Create_Status_Component (max_life, 0);

    var IVector size            = val IVector(8, 10);
    var IMoving_Obj imov_obj    = call Create_Moving_Obj( start_pos, size);
    imov_obj.iboundaries.bound_right        = false;
    imov_obj.ikinematic.drag                = 0.95;
    imov_obj.ikinematic.acceleration        = val IVector ( 300, 300);

    var IActor.IEnemie.IBrat ibrat = val IActor.IEnemie.IBrat ( imov_obj,  _, _, istatus, &itarget);
    escape ibrat;
end

code/await Brat( var& IActor.IEnemie.IBrat ibrat ) -> none
do
    event bool e_stop_state;
    var IVector sprite_offset       = val IVector(24, 25);

    var IAnimation ianim_flying         = val IAnimation( call Create_Image_Quad( "assets/img/actors/brat-flying.bmp",          sprite_offset, 4), 10);
    var IAnimation ianim_attack_start   = val IAnimation( call Create_Image_Quad( "assets/img/actors/brat-attack-start.bmp",    sprite_offset, 3), 16);
    var IAnimation ianim_attacking      = val IAnimation( call Create_Image_Quad( "assets/img/actors/brat-attacking.bmp",       sprite_offset, 2), 10);
    var IAnimation ianim_attack_end     = val IAnimation( call Create_Image_Quad( "assets/img/actors/brat-attack-end.bmp",      sprite_offset, 1), 10);
    var IAnimation ianim_hit            = val IAnimation( call Create_Image_Quad( "assets/img/actors/brat-hit.bmp",             sprite_offset, 2), 10);

    var real target_radius  = 64;
    var real slow_radius    = 96;
    var int attack_prep     = 300;
    var int attack_cooldown = 1500;
    var real normal_acc     = 300;
    var real attack_acc     = 600;
    var real stop_distance  = 10;

    ibrat.imov_obj.iboundaries.bound_right        = true;
    par/or do
        pause/if e_stop_state do
            loop do
                par/or do
                    par/or do
                        loop do
                            every SDL_REDRAW do
                                var IVector target_direction = call VSub(ibrat.itarget.imov_obj.iaabb.center, ibrat.imov_obj.iaabb.center);
                                ibrat.imov_obj.iaabb.scale.x = _fabs(ibrat.imov_obj.iaabb.scale.x) * call Signed(target_direction.x);
                            end
                        end
                    with
                        loop do
                            await Animation (&ianim_flying, &ibrat.imov_obj.iaabb.center, &ibrat.imov_obj.iaabb.scale, &ibrat.imov_obj.iaabb.rotate_angle );
                        end
                    with
                        await (attack_cooldown)ms;
                        ibrat.imov_obj.ikinematic.acceleration        = val IVector ( normal_acc, normal_acc);
                        await Arrive_Behavior (&ibrat.imov_obj, &ibrat.itarget.imov_obj.iaabb.center, target_radius, slow_radius);
                        await (attack_prep)ms;
                    end
                    
                    // Start Attack
                    await Animation (&ianim_attack_start, &ibrat.imov_obj.iaabb.center, &ibrat.imov_obj.iaabb.scale, &ibrat.imov_obj.iaabb.rotate_angle );

                    // Attacking
                    par/or do
                        loop do
                            await Animation (&ianim_attacking, &ibrat.imov_obj.iaabb.center, &ibrat.imov_obj.iaabb.scale, &ibrat.imov_obj.iaabb.rotate_angle );
                        end
                    with
                        var IVector target_direction = call VSub(ibrat.itarget.imov_obj.iaabb.center, ibrat.imov_obj.iaabb.center);
                        ibrat.imov_obj.iaabb.scale.x = _fabs(ibrat.imov_obj.iaabb.scale.x) * call Signed(target_direction.x);
                        ibrat.imov_obj.ikinematic.acceleration  = val IVector ( attack_acc, attack_acc);
                        var IVector target_position             = ibrat.itarget.imov_obj.iaabb.center;
                        ibrat.imov_obj.isteering                = call Steering_Seek(ibrat.imov_obj.ikinematic, target_position);
                        par/or do
                            every SDL_DT do
                                var IVector current_distance = call VSub(target_position, ibrat.imov_obj.iaabb.center);
                                if call VLength(current_distance) > stop_distance then
                                    if call Signed(ibrat.imov_obj.isteering.linear.x) != call Signed(current_distance.x) then
                                        break;
                                    end
                                    if call Signed(ibrat.imov_obj.isteering.linear.y) != call Signed(current_distance.y) then
                                        break;
                                    end
                                end
                            end
                        with
                            await ibrat.hit;
                        end
                        ibrat.imov_obj.isteering                = val ISteering_Component (IVector(0,0), 0);
                    end
                    // Stop Attack
                    await Animation (&ianim_attack_end, &ibrat.imov_obj.iaabb.center, &ibrat.imov_obj.iaabb.scale, &ibrat.imov_obj.iaabb.rotate_angle );
                    
                with
                    await resume;
                end
            end
        end
    with
        await ibrat.hit;
        emit e_stop_state(true);
        loop do 
            var IVector acceleration    = outer.null_vector;
            ibrat.imov_obj.isteering    = val ISteering_Component(_, _);
            ibrat.imov_obj.ikinematic.velocity   = val IVector( -10, 0 );
            if ibrat.istatus.current_life > 0 then
                par/or do
                    await ibrat.hit;
                with
                    ianim_hit.iquad.color = val Color( 255, 182, 182);
                    await 150ms;
                    ianim_hit.iquad.color = val Color( 255, 255, 255);
                    await FOREVER;
                with
                    await Animation (&ianim_hit, &ibrat.imov_obj.iaabb.center, &ibrat.imov_obj.iaabb.scale, &ibrat.imov_obj.iaabb.rotate_angle );
                    emit e_stop_state(false);
                    await FOREVER;
                end
                ianim_hit.iquad.color = val Color( 255, 255, 255);
            else
                break;
            end
        end
    with
        await ibrat.destroy;
    end
end

code/await/dynamic Actor ( var&/dynamic IActor.IEnemie.IBrat iactor, pool&[] Actor actors ) -> none
do
    await Brat (&iactor);
end

